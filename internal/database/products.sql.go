// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: products.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const getMyProduct = `-- name: GetMyProduct :many
SELECT product_id, user_id, product_name, product_photo, price, visibility FROM products WHERE user_id=$1
`

func (q *Queries) GetMyProduct(ctx context.Context, userID string) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, getMyProduct, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ProductID,
			&i.UserID,
			&i.ProductName,
			&i.ProductPhoto,
			&i.Price,
			&i.Visibility,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicProduct = `-- name: GetPublicProduct :many
SELECT product_id, u.user_id, product_name, product_photo, price, visibility, v.user_id, username, email, phonenumber, password, last_login, isemailverified, isphoneverified, v.username FROM products u
JOIN users v ON v.user_id = u.user_id
WHERE u.user_id!=$1 AND u.visibility=true
`

type GetPublicProductRow struct {
	ProductID       string         `json:"product_id"`
	UserID          string         `json:"user_id"`
	ProductName     string         `json:"product_name"`
	ProductPhoto    uuid.UUID      `json:"product_photo"`
	Price           int32          `json:"price"`
	Visibility      bool           `json:"visibility"`
	UserID_2        string         `json:"user_id_2"`
	Username        string         `json:"username"`
	Email           string         `json:"email"`
	Phonenumber     sql.NullString `json:"phonenumber"`
	Password        string         `json:"password"`
	LastLogin       time.Time      `json:"last_login"`
	Isemailverified bool           `json:"isemailverified"`
	Isphoneverified bool           `json:"isphoneverified"`
	Username_2      string         `json:"username_2"`
}

func (q *Queries) GetPublicProduct(ctx context.Context, userID string) ([]GetPublicProductRow, error) {
	rows, err := q.db.QueryContext(ctx, getPublicProduct, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPublicProductRow
	for rows.Next() {
		var i GetPublicProductRow
		if err := rows.Scan(
			&i.ProductID,
			&i.UserID,
			&i.ProductName,
			&i.ProductPhoto,
			&i.Price,
			&i.Visibility,
			&i.UserID_2,
			&i.Username,
			&i.Email,
			&i.Phonenumber,
			&i.Password,
			&i.LastLogin,
			&i.Isemailverified,
			&i.Isphoneverified,
			&i.Username_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const postProduct = `-- name: PostProduct :one
INSERT INTO products(user_id, product_name, price, visibility)
VALUES ($1,$2,$3,$4)
RETURNING product_id, user_id, product_name, product_photo, price, visibility
`

type PostProductParams struct {
	UserID      string `json:"user_id"`
	ProductName string `json:"product_name"`
	Price       int32  `json:"price"`
	Visibility  bool   `json:"visibility"`
}

func (q *Queries) PostProduct(ctx context.Context, arg PostProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, postProduct,
		arg.UserID,
		arg.ProductName,
		arg.Price,
		arg.Visibility,
	)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.UserID,
		&i.ProductName,
		&i.ProductPhoto,
		&i.Price,
		&i.Visibility,
	)
	return i, err
}
